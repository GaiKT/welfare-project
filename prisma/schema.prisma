// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// =============================================
// ADMIN & USER MODELS
// =============================================

model Admin {
  id                 String    @id @default(uuid())
  username           String    @unique
  email              String?   @unique
  password           String
  name               String?
  image              String?
  role               AdminRole @default(ADMIN)
  isActive           Boolean   @default(true)
  isFirstLogin       Boolean   @default(true)
  mustChangePassword Boolean   @default(true)
  signatureUrl       String? // Path to digital signature image
  lastLogin          DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  auditLogs       AuditLog[]
  accounts        Account[]
  sessions        Session[]
  approvals       ClaimApproval[]
  claimsAsAdmin   WelfareClaims[] @relation("AdminApprover")
  claimsAsManager WelfareClaims[] @relation("ManagerApprover")
}

enum AdminRole {
  PRIMARY
  ADMIN
  MANAGER
}

model User {
  id                 String    @id @default(uuid())
  identity           String    @unique // Employee ID or similar identifier
  firstName          String
  lastName           String
  title              String
  email              String?   @unique
  phone              String?
  image              String? // Profile image URL
  password           String? // Optional password for user login
  isActive           Boolean   @default(true)
  isFirstLogin       Boolean   @default(true)
  mustChangePassword Boolean   @default(true)
  lastLogin          DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  claims        WelfareClaims[]
  welfareQuotas WelfareQuota[]
  notifications Notification[]
  claimComments ClaimComment[]
}

// =============================================
// WELFARE TYPE MODELS (NEW STRUCTURE)
// =============================================

// Main welfare type (e.g., Funeral, Medical, Marriage, etc.)
model WelfareType {
  id          String   @id @default(uuid())
  code        String   @unique // FUNERAL, MEDICAL, MARRIAGE, NEWBORN, DISASTER
  name        String // ชื่อสวัสดิการ
  description String?  @db.Text
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0) // For ordering in UI
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  subTypes          WelfareSubType[]
  requiredDocuments RequiredDocument[]
}

// Sub-type of welfare with specific conditions
// e.g., Funeral -> Member (10,000), Family (10,000), Parent (5,000)
model WelfareSubType {
  id            String  @id @default(uuid())
  welfareTypeId String
  code          String // MEMBER, FAMILY, PARENT, INPATIENT, etc.
  name          String // ชื่อประเภทย่อย
  description   String? @db.Text

  // Amount settings
  amount   Float // จำนวนเงินต่อครั้ง/คืน (e.g., 10000, 500)
  unitType WelfareUnitType @default(LUMP_SUM) // วิธีคำนวณ

  // Claim limits
  maxPerRequest     Float? // สูงสุดต่อการยื่น 1 ครั้ง (e.g., 5000 for medical)
  maxPerYear        Float? // สูงสุดต่อปีงบประมาณ (e.g., 10000 for medical)
  maxLifetime       Float? // สูงสุดตลอดการเป็นสมาชิก (e.g., 20000 for disaster)
  maxClaimsPerYear  Int? // จำนวนครั้งสูงสุดต่อปี
  maxClaimsLifetime Int? // จำนวนครั้งสูงสุดตลอดการเป็นสมาชิก (e.g., 1 for marriage)

  isActive  Boolean  @default(true)
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  welfareType   WelfareType     @relation(fields: [welfareTypeId], references: [id], onDelete: Cascade)
  claims        WelfareClaims[]
  welfareQuotas WelfareQuota[]

  @@unique([welfareTypeId, code])
  @@index([welfareTypeId])
}

// Unit type for calculating welfare amount
enum WelfareUnitType {
  LUMP_SUM // เหมาจ่าย (fixed amount per claim)
  PER_NIGHT // ต่อคืน (amount × nights for medical)
  PER_INCIDENT // ต่อครั้ง (amount per incident for disaster)
}

// Required documents for each welfare type
model RequiredDocument {
  id            String   @id @default(uuid())
  welfareTypeId String
  name          String // ชื่อเอกสาร (e.g., "สำเนาบัตรประชาชนสมาชิก")
  description   String? // คำอธิบายเพิ่มเติม
  isRequired    Boolean  @default(true) // จำเป็นต้องแนบหรือไม่
  sortOrder     Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  welfareType WelfareType @relation(fields: [welfareTypeId], references: [id], onDelete: Cascade)

  @@index([welfareTypeId])
}

// Beneficiary relation (for funeral welfare)
enum BeneficiaryRelation {
  SELF // สมาชิก
  SPOUSE // คู่สมรส
  CHILD // บุตร
  FATHER // บิดา
  MOTHER // มารดา
}

// =============================================
// WELFARE CLAIMS MODELS
// =============================================

model WelfareClaims {
  id               String @id @default(uuid())
  userId           String
  welfareSubTypeId String // Link to WelfareSubType instead of old Welfare

  // Amount calculation
  requestedAmount Float // จำนวนเงินที่ขอเบิก
  approvedAmount  Float? // จำนวนเงินที่อนุมัติ
  nights          Int? // จำนวนคืน (for medical welfare)

  // Beneficiary info (for funeral, newborn welfare)
  beneficiaryName     String? // ชื่อผู้รับผลประโยชน์/ผู้เสียชีวิต
  beneficiaryRelation BeneficiaryRelation? // ความสัมพันธ์

  // Additional info
  description   String?   @db.Text
  incidentDate  DateTime? // วันที่เกิดเหตุ/วันสมรส/วันเสียชีวิต
  hospitalName  String? // ชื่อโรงพยาบาล (for medical)
  admissionDate DateTime? // วันที่เข้ารักษา
  dischargeDate DateTime? // วันที่ออกจาก รพ.

  // Status & workflow
  status          ClaimStatus @default(PENDING)
  fiscalYear      Int // Fiscal year (e.g., 2025 for July 2024 - June 2025)
  submittedDate   DateTime    @default(now())
  completedDate   DateTime?
  rejectionReason String?     @db.Text

  // Approval tracking
  adminApproverId   String?
  adminApprovedAt   DateTime?
  managerApproverId String?
  managerApprovedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user            User            @relation(fields: [userId], references: [id])
  welfareSubType  WelfareSubType  @relation(fields: [welfareSubTypeId], references: [id])
  adminApprover   Admin?          @relation("AdminApprover", fields: [adminApproverId], references: [id])
  managerApprover Admin?          @relation("ManagerApprover", fields: [managerApproverId], references: [id])
  documents       ClaimDocument[]
  approvals       ClaimApproval[]
  comments        ClaimComment[]
  notifications   Notification[]

  @@index([userId])
  @@index([welfareSubTypeId])
  @@index([fiscalYear])
  @@index([status])
}

enum ClaimStatus {
  PENDING // User submitted, waiting for Admin review
  IN_REVIEW // Admin is reviewing
  ADMIN_APPROVED // Admin approved, waiting for Manager
  MANAGER_APPROVED // Manager approved (same as COMPLETED)
  REJECTED // Rejected by Admin or Manager
  COMPLETED // Fully approved and processed
}

// Model for claim document attachments
model ClaimDocument {
  id           String   @id @default(uuid())
  claimId      String
  documentName String // ชื่อประเภทเอกสาร (e.g., "สำเนาบัตรประชาชน")
  fileName     String
  fileUrl      String // Path or URL to the file
  fileType     String // MIME type (e.g., application/pdf, image/png)
  fileSize     Int // File size in bytes
  uploadedAt   DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  claim WelfareClaims @relation(fields: [claimId], references: [id], onDelete: Cascade)

  @@index([claimId])
}

// Model for tracking approval flow history
model ClaimApproval {
  id           String      @id @default(uuid())
  claimId      String
  approverId   String
  approverRole AdminRole // PRIMARY, ADMIN, or MANAGER
  status       ClaimStatus
  comments     String?     @db.Text
  approvedAt   DateTime    @default(now())
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  claim    WelfareClaims @relation(fields: [claimId], references: [id], onDelete: Cascade)
  approver Admin         @relation(fields: [approverId], references: [id])

  @@index([claimId])
  @@index([approverId])
}

// Model for claim comments (for requesting revisions)
model ClaimComment {
  id        String   @id @default(uuid())
  claimId   String
  commentBy String // User ID or Admin ID
  userType  UserType // ADMIN or USER
  comment   String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  claim WelfareClaims @relation(fields: [claimId], references: [id], onDelete: Cascade)
  user  User?         @relation(fields: [commentBy], references: [id])

  @@index([claimId])
  @@index([commentBy])
}

enum UserType {
  ADMIN
  USER
}

// =============================================
// QUOTA & TRACKING MODELS
// =============================================

// Model for tracking welfare quota per user per fiscal year
model WelfareQuota {
  id               String @id @default(uuid())
  userId           String
  welfareSubTypeId String // Link to WelfareSubType
  fiscalYear       Int // e.g., 2025 for July 2024 - June 2025

  // Yearly tracking
  usedAmountYear Float @default(0) // จำนวนเงินที่ใช้ในปีนี้
  usedClaimsYear Int   @default(0) // จำนวนครั้งที่เบิกในปีนี้

  // Lifetime tracking
  usedAmountLifetime Float @default(0) // จำนวนเงินที่ใช้ตลอดการเป็นสมาชิก
  usedClaimsLifetime Int   @default(0) // จำนวนครั้งที่เบิกตลอดการเป็นสมาชิก

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user           User           @relation(fields: [userId], references: [id])
  welfareSubType WelfareSubType @relation(fields: [welfareSubTypeId], references: [id])

  @@unique([userId, welfareSubTypeId, fiscalYear])
  @@index([userId])
  @@index([welfareSubTypeId])
  @@index([fiscalYear])
}

// =============================================
// NOTIFICATION & AUDIT MODELS
// =============================================

// Model for in-app notifications
model Notification {
  id             String           @id @default(uuid())
  userId         String // Can be User or Admin
  type           NotificationType
  title          String
  message        String           @db.Text
  isRead         Boolean          @default(false)
  relatedClaimId String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  user  User?          @relation(fields: [userId], references: [id])
  claim WelfareClaims? @relation(fields: [relatedClaimId], references: [id])

  @@index([userId])
  @@index([isRead])
}

enum NotificationType {
  CLAIM_SUBMITTED
  CLAIM_APPROVED
  CLAIM_REJECTED
  CLAIM_COMMENT
  CLAIM_COMPLETED
  SYSTEM
}

model AuditLog {
  id        String   @id @default(uuid())
  action    String
  entity    String
  entityId  String
  timestamp DateTime @default(now())
  adminId   String

  admin Admin @relation(fields: [adminId], references: [id])

  @@index([adminId])
}

// =============================================
// NEXTAUTH.JS REQUIRED MODELS
// =============================================

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user Admin @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         Admin    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
